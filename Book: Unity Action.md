2022.3.20
#  Unity Action 初阅读
## <txt color = orange>关于Unity的优缺点</txt>
### 优点：
#### -----1. 可视化工作流
不是很能理解Unity的可视化工作流是什么，不需要自己设置自己的开发环境？

#### -----2. 跨平台开发
可跨多个平台进行开发，例如：IOS、安卓 Xbox

#### -----3. 组件系统
可任意挂载组件，让一个物体赋予开发者需要的属性，脚本也是组件

### 缺点
#### -----1. 难以确定哪些物体挂载了某些指定组件
Find Reference in Scene 可以找到，但显示出的所有挂在物体以及他的子物体，且搜索列表中并体现不出父子关系

#### -----2。与外部代码库链接困难
我的理解可能就是，类似于using system，需要手动添加，不知道对不对

#### -----3.方法和选择太多，选择困难
举个例子，就我需要一个滑动条，但UI中类似的组件有Slider和Scorllbar，不知道该选哪个的情况下，需要每个都尝试一遍

## <txt color = orange>关于Unity的面板以及常用编码器</txt>
### -----Scene View 
场景面板，大多操作在这个面板中进行，例如物体的旋转、缩放、物体位置
### -----Game View
游戏面板，检查游戏效果

可在Scene View 和Game View中同时观察，确认最佳效果

### -----旋转、缩放、移动： 常见改变物体属性操作
<img width="407" alt="截屏2022-03-21 上午2 01 19" src="https://user-images.githubusercontent.com/97930502/159176060-b9390bd5-e757-4566-a418-3d8b393438e8.png">
<p>可点击图片中的按钮对物体属性进行改变</p>

也可在inspector中对物体的大小，旋转角度，位置等进行改变

<img width="271" alt="截屏2022-03-21 上午2 03 12" src="https://user-images.githubusercontent.com/97930502/159176120-1aa15920-399a-4a29-9e50-9f97fdc11f6c.png">

也可通过键盘操作（但我好像三个都会用，想到哪个用哪个）

### -----Hierarchy view、the Inspector panel、Project、Console tabs
Hierarchy 记录场景中的物体及其父子关系（这里的物体一定要分好类，不然查找很麻烦）
Inspectoe 记录所选物体属性以及其搭载的组件
Project 显示项目中所有资源（这里的资源也需要分好类）
Console tabs 可使用其返回debug的信息

### -----推荐使用Visual Studio


2022.3.27
# 2.Unity Action第二~第三节

## 印象深刻的点

### 1. 本地坐标和世界坐标
（可用Transform（）进行转换）

### 2. 不同计算机拥有不同点处理性能，可能会导致同一代码不同的结果
（例如Update（）和FixUpdate（），联想到，若在对物理性能要求较高的功能使用Update（）时，当同时线上联机玩一款游戏时，可能会出现不同频的状况）

### 3. [RequiredComponent(typeOfCharacterController)] 用到的频率较高
（当代码需要某个组件但物体却没有附加该组件时，会发生错误，这是我常犯的错误，但这行代码能很好的避免这点，提高健壮性）

### 4. 对于用射线模拟射击过程
（这个，类似于之前的注释特效“焦点”处理，但现在联想到，若相机为父，两只手柄为子，将射线从两只手柄中投射出，可能能做出手柄射线有焦点的效果）

### 5. 利用碰撞体实现撞击效果
（碰撞体是实现撞击效果，看到好多游戏的敌人和玩家的攻击方式是通过碰撞体实现，但在使用碰撞体时，一定要注意各个碰撞体之间存在的相互作用，在刚开始做毕业设计时，就发生过山体的碰撞体和敌人的碰撞体重叠，导致点击敌人无法触发主角攻击效果的现象）

### 6. 有关预制件
（多个场景中存在可重用的GameObject时，大多情况会选择将它作为预制件,但预制件也存在缺陷，当场景在Editor的状态下可对预制件进行增加GameObject，但不可轻易删除其中含有的GameObject，但这点也保证了预制件比较稳定，可以在不同场景有其特别的“预制件”）

2022.04.05

# unity in Action 阅读
## 1.印象深刻的点（也可能以后会用到）
### pixel-perfect
这里给出了一个公式（SCREEN_SIZE/2/100f），可使得屏幕像素和图像像素一一对应，应该是用来更好的展现图片效果。

### 2.Knuth洗牌算法
<img width="538" alt="截屏2022-04-06 03 41 15" src="https://user-images.githubusercontent.com/97930502/161836481-8a8bef2b-2078-4b6a-bfd9-267ce477a30b.png">
对这个算法有点好奇，就去查看了代码，发现他好像可以变成一个排序算法，记录自己的前一个数据，在剩余未查找的数中随机取一个比自己小的数，将两数位置互换，（若为增序排列，且前一个数据比自己大，降序则反之，则将Resequence设为true，再准备执行下一轮排序），但在这种排序方法，可能时间复杂度会比较高，吼吼吼吼。

### 3.有关于画辅助线Gizmos
<img width="557" alt="截屏2022-04-06 04 05 16" src="https://user-images.githubusercontent.com/97930502/161839958-99be6646-daa3-4c44-b17d-052b7e77c2b0.png">
这歌前两天刚用到，雨桐教我用这个画出射线的辅助线，还有印象。

### 4.有关于SmoothDamp()
  书上说的是，让值平滑的过度到一个新的值，感觉以后会用到（处理GameObject移动时候，不会过于直接、生硬）
  
### 5.通过响应事件更新游戏
到现在，我接触到的可用于全局保存或存储的方法
#### 1）.static（这应该算不上是一个方法）
#### 2）.ScriptableObject
#### 3）.单例（这个只是看到过，但没有用过）
#### 4）.广播 message（这个只用到过一点点）
#### 5) .PlayerPrefs

### 6.
<img width="841" alt="截屏2022-04-06 04 21 43" src="https://user-images.githubusercontent.com/97930502/161842414-88904571-24e5-44ce-90a1-ae9fe36b1522.png">
记录下这段的代码的原因是，我觉得它神奇的点在于，他直接用image作为存储的关键字，这和PlayerPrefs的做法有些类似，但又比PlayerPrefs更有意思，他应该能记录更多除了字符串和图片以外的东西
<img width="579" alt="截屏2022-04-06 04 25 35" src="https://user-images.githubusercontent.com/97930502/161843031-3ffc9cfb-9cef-4ddd-b709-b0ac91b19001.png">
好吧，只是我对GUI.Box的认识太浅了

### 7.有关随气候变换的天空盒
起初，我认为天空盒变换只是单纯的改变天空和的颜色或者图文样式，后来才知道，天空盒的更换可能会带来场景里的光源的强度或者类型也要进行变化，看到这里的时候，觉得黑夜版灵境有着落了，但是之后的内容越看越懵，以后还得再回顾！

### 8. 继承式代码
<img width="740" alt="截屏2022-04-10 20 47 16" src="https://user-images.githubusercontent.com/97930502/162618874-262c8ecf-d5f0-4ced-a9fd-45c65704fc3d.png">

<img width="711" alt="截屏2022-04-10 20 44 07" src="https://user-images.githubusercontent.com/97930502/162618745-a0942b31-6107-46db-aebc-51fec9b8ca80.png">
继承式代码在我现在看来是一种比较新颖的写法，这更好的解决了之前总是会在代码中引用别的代码方法的问题

### 9.NavMesh 
这个方法印象深刻的点在于，他能实现自动寻址，用一些简单的操作可将场景中的物体分为可行走和不可行走，减少了代码量（其实也是因为上课的时候老师教到这个，就觉得这个好神奇）

### 10.Camera's clipping
之前处理到过类似的问题，当clipping过大时，近处的物体就会出现裁切的样子，需要在适当的时候调整clipping的远近
